package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"context"
	"github.com/odysseia-greek/agora/plato/config"
	pbartrippos "github.com/odysseia-greek/apologia/aristippos/proto"
	pbkritias "github.com/odysseia-greek/apologia/kritias/proto"
	"github.com/odysseia-greek/apologia/sokrates/graph/model"
	pbxenofon "github.com/odysseia-greek/apologia/xenofon/proto"
)

// MediaAnswer is the resolver for the mediaAnswer field.
func (r *queryResolver) MediaAnswer(ctx context.Context, input *model.MediaAnswerInput) (*model.ComprehensiveResponse, error) {
	requestID, _ := ctx.Value(config.HeaderKey).(string)

	pb := &pbartrippos.AnswerRequest{
		Theme:         *input.Theme,
		Set:           *input.Set,
		Segment:       *input.Segment,
		Comprehensive: *input.Comprehensive,
		Answer:        *input.Answer,
		QuizWord:      *input.QuizWord,
	}

	return r.Handler.CheckMedia(pb, requestID)
}

// MediaQuiz is the resolver for the mediaQuiz field.
func (r *queryResolver) MediaQuiz(ctx context.Context, input *model.MediaQuizInput) (*model.MediaQuizResponse, error) {
	requestID, _ := ctx.Value(config.HeaderKey).(string)

	pb := &pbartrippos.CreationRequest{
		Theme:   *input.Theme,
		Set:     *input.Set,
		Segment: *input.Segment,
	}

	if input.Order != nil {
		pb.Order = *input.Order
	}

	for _, word := range input.ExcludeWords {
		pb.ExcludeWords = append(pb.ExcludeWords, *word)
	}

	return r.Handler.CreateMediaQuiz(pb, requestID)
}

// MultipleChoiceAnswer is the resolver for the multipleChoiceAnswer field.
func (r *queryResolver) MultipleChoiceAnswer(ctx context.Context, input *model.MultipleChoiceAnswerInput) (*model.ComprehensiveResponse, error) {
	requestID, _ := ctx.Value(config.HeaderKey).(string)

	pb := &pbkritias.AnswerRequest{
		Theme:         *input.Theme,
		Set:           *input.Set,
		Comprehensive: *input.Comprehensive,
		Answer:        *input.Answer,
		QuizWord:      *input.QuizWord,
	}

	return r.Handler.CheckMultipleChoice(pb, requestID)
}

// MultipleChoiceQuiz is the resolver for the multipleChoiceQuiz field.
func (r *queryResolver) MultipleChoiceQuiz(ctx context.Context, input *model.MultipleQuizInput) (*model.MultipleChoiceResponse, error) {
	requestID, _ := ctx.Value(config.HeaderKey).(string)

	pb := &pbkritias.CreationRequest{
		Theme: *input.Theme,
		Set:   *input.Set,
	}

	if input.Order != nil {
		pb.Order = *input.Order
	}

	for _, word := range input.ExcludeWords {
		pb.ExcludeWords = append(pb.ExcludeWords, *word)
	}

	return r.Handler.CreateMultipleChoiceQuiz(pb, requestID)
}

// AuthorBasedAnswer is the resolver for the authorBasedAnswer field.
func (r *queryResolver) AuthorBasedAnswer(ctx context.Context, input *model.AuthorBasedAnswerInput) (*model.AuthorBasedAnswerResponse, error) {
	requestID, _ := ctx.Value(config.HeaderKey).(string)

	pb := &pbxenofon.AnswerRequest{
		Theme:    *input.Theme,
		Set:      *input.Set,
		Segment:  *input.Segment,
		Answer:   *input.Answer,
		QuizWord: *input.QuizWord,
	}

	return r.Handler.CheckAuthorBased(pb, requestID)
}

// AuthorBasedQuiz is the resolver for the authorBasedQuiz field.
func (r *queryResolver) AuthorBasedQuiz(ctx context.Context, input *model.AuthorBasedInput) (*model.AuthorBasedResponse, error) {
	requestID, _ := ctx.Value(config.HeaderKey).(string)

	pb := &pbxenofon.CreationRequest{
		Theme:   *input.Theme,
		Set:     *input.Set,
		Segment: *input.Segment,
	}

	for _, word := range input.ExcludeWords {
		pb.ExcludeWords = append(pb.ExcludeWords, *word)
	}

	return r.Handler.CreateAuthorBasedQuiz(pb, requestID)
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
